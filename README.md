## 1.1 基礎理論（離散数学）

- 2 進数と n 進数
  - 2 進数は 0 と 1 で数を表現したもの
  - 2 倍ずつ桁が上がっていく
  - 例 （1,2,4,8 を 2 進数で表すと 1,10,100,1000）
  - 10 進数は 10 倍ずつ桁が上がっていく
  - 例 （1,10,100,1000 を 2 進数で表すと 1,10,100,1000）

## 10.1 OS の仕事

- コンピュータの基本動作を実現する基本ソフトウェアのこと！
- アプリケーションの管理をしている（メモリの管理、ファイル管理、ハードウェアの管理）
- ハードウェア（コンピュータ）、ソフトウェア（システムソフトウェアと応用ソフトウェア）
  - 応用ソフトウェアは、各種アプリケーション
  - システムソフトウェアは DBMS などのミドルウェアと OS の基本的ソフトウェアの２つある
  - 基本的ソフトウェア
    - 制御プログラム　（OS の中核であり、カーネルと呼ばれる）
      - ハードウェアを管理して、コンピュータを効率的に利用できるようにしたもの
      - ジョブ管理
      - タスク管理
      - 記憶管理
      - データ（ファイル）管理
    - 言語プロセッサ（言語処理プログラム）
      - プログラミング言語で書かれたものを機械語に翻訳するプログラム
    - サービスプログラム（ユーティリティ）
      - 補助的なプログラムで、ファイル圧縮プログラムなどが該当する

## 10.2 ジョブ管理

- 利用者からみた仕事の単位をジョブという
- ジョブを効率よく処理するように実行スケジュールを管理する
- バッチ処理というものがあり、複数のジョブをまとめて実行スケジュールに登録してできるかぎり効率よくジョブを処理するようになっている
- マスタスケジューラという管理プログラムが橋渡しになっている -　マスタスケジューラはジョブの実行をジョブスケジューラに依頼する
  - リーダ：　依頼されたジョブを入力して、ジョブ待ち行列に登録
  - イニシエータ: 優先度の高いジョブを持ってきて、ジョブステップに分解します
  - ターミネータ：実行を終えたジョブに割り当てれてたハードウェア資源を開放してジョブの結果を出力まち行列に登録します
  - ライタ：優先度高いものから順に、ジョブ結果を出力します
- スプーリング
  - スプーリングとは低速な装置どのデータをやりとりする際に、高速な磁気ディスクを介して処理効率を高める方法
    - 待ち行列で一時的に蓄えておく
  - スループットの向上に役立つ。（スループットとは、CPU が単位時間あたりに処理できる仕事量のこと）

## 11.1 プログラミング言語とは

- コンピュータに作業指示を出すための言葉
- 機械語（0 と 1 で表現するもの）にも変換しやすくて、人間にも理解しやすい言葉の中間をとったようなもの

  #### 演習問題で知ったこと

- C 言語の特徴は「高水準言語であるが、システムの細部まで記述ができ、その成り立ちからシステム記述言語として位置づけられている」
- Java の特徴は「メモリ管理のためのガーベジコレクション機能がある」

## 11.2 言語プロセッサ

- 言語プロセッサとは、翻訳作業を行うようなもので、ソースコードをより CPU が理解しやすいような形にかえるプログラムのことをいいます。
- 例はコンパイラ、アセンブラ、インタプリタなどがある。
  - コンパイラがソースコードの内容を翻訳して目的プラグラムを作成する
  - アセンブラがアセンブラ言語で書かれたものを機械語に翻訳する
  - インタプリタがソースコードで書かれた命令をを一つずつ機械語に翻訳する
- インタプリタ（HTML や CSS，Ruby,Python、JavaScript,PHP）
  - 逐次的な処理
  - その場で変更点を確認しながら作業ができる
- コンパイラ（TypeScript, C 言語、Java など）
  - コンパイラがソースコード内容をすべて把握してから目的プログラムを作成する
  - 作業途中に確認のために動かしてみるということができない
- プリコンパイラ、ジェネレータ、エミュレータ、クロスコンパイラ

  #### 演習問題で知ったこと

  - Q. あるコンピュータ上で、異なる命令形式のコンピュータで実行できる目的プラムを生成する言語処理プログラム（言語プロセッサ）をなんていう
  - A. クロスコンパイラ（例: MacOS 上でコンパイルして、Android 上で動く目的プログラムを生成する）

## 11.3 コンパイラ方式でのプログラム実行手順

- 実際に CPU が実行できるまでには以下の流れがある

  - ソースコードをコンパイラが翻訳して目的プログラムを生成する
  - リンカ（実行可能ファイルを生成するプログラム）が目的プログラムのモジュール郡や外部のライブラリのモジュール郡をリンクする
  - ローダが実行可能ファイルを主記憶に読み込ませる（ロード）

- コンパイラの仕事

  - 字句解析
  - 構文解析
  - 意味解析
  - 最適化
  - コードを生成

- リンカの仕事

  - モジュール郡をつなぎあわせるリンクを行う（連係編集）
  - 事前にリンクする静的リンク
  - 実行時にリンクする動的リンク

- ローダの仕事

  - 実行可能ファイル（ロードモジュール）を主記憶に読み込ませる（ロード）

  #### 演習問題で知ったこと

  - Q. 目的プログラムの実行時間を短くするためにコンパイラが行う最適化の方法
  - A. 定数が格納されている変数を追跡して、途中で変更されていないことが確認できれば、変数を定数に置き換えるなど

## 11.4 構造化プログラミング

- 構造化プログラミングとは、機能単位でプログラムを分けて部品にし、その組み合わせによって全体を形づくるという考え方。
- サブルーチンという形で別のモジュールに切り出していく -　構造化プログラミングは基本的に以下３つの制御構造だけを使っている
  - 順次構造
    - 上から順に処理をしていく
  - 選択構造
    - 条件によって分岐させて、いずれかの処理を行う
  - 繰り返し構造
    - ある一定の条件が満たされるまで同じ処理を繰り返す

## 11.5 変数は入れ物として使う箱

- 変数は名前つきの箱である
- 変数の保存期間
  - プログラムは関数でブロック単位にする
  - このブロックのそとに定義された変数は大域変数（グローバル変数、外部変数）という
    - プログラムが終了するまでは変数の領域が確保されている
  - 逆に関数内、ブロック内に書かれた変数を局所変数（ローカル変数）という
    - static をつければ静的変数となり、グローバル変数とおなじく、プログラムが終了するまでは領域が確保されている
    - 一方で動的変数の場合、関数が終了次第で変数の領域は破棄される
- 関数の引数には仮引数（定義元で入っている引数）と実引数（呼び出し元で実際にはいる引数）の２つがある

  - 実引数を仮引数にわたす方法には、値渡しと参照渡しがある。
    - 値渡しは、実引数をコピーしてものを仮引数に渡している
    - 参照渡しは、実引数にしか実体を持たず、その実体の情報を仮引数に渡し、定義元から呼び出し元の引数を参照して値を入れる
    - 参照渡しの場合、呼び出し元の変数の中身を関数側から操作することが可能となる

  ```Javascript
    function add(obj) {
      obj.x = obj.x + obj.y;
      obj.y = obj.x + obj.y;
    }

    let myObject = { x: 2, y: 2 };
    add(myObject);

    console.log(myObject.x);
    console.log(myObject.y);
  ```

## 11.6 アルゴリズムとフローチャート

- コンピュータに書かれたプログラムの作業手順をアルゴリズムという。
- フロ-チャートと用いて、考えてみるとよい。

## 11.7 データ構造

- データ構造
  - 配列
    - index（添字）を使って直接アクセスできる
    - 一次元配列、二次元配列がある
    - データ領域をまとめて確保するため、データの挿入や削除が苦手？
  - リスト
    - ポインタと呼ばれる次のデータの場所を示すものがあり、数珠繋ぎでデータを構成できる
    - ポインタを変更すればよいので、挿入や削除などが簡単にできる
    - 主に３つあり、単一リスト、双方リスト、循環リスト
      - 単一リストは 1 ポインタを使ってつなぐ
      - 双方リストは２つのポインタを前後に配置することで前後のデータがわかるようになる
      - 循環リストは、最後のポインタを最初のデータに向くようにする
  - キュー
    - FIFO（先入れ先出し）
    - エンキューとデキュー
  - スタック
    - LIFO（先入れ後出し）
    - 逆ポーランド記法という考え方ある
    - 項はプッシュして、演算子ならば２つの項を pop して答えを導き出す

## 11.8 ツリー構造

- 木構造は、階層構造を持つデータで広く用いられ、データの探索や整列などの用途にも使われるデータ構造です。
- 用いられる場面としては以下のとおり
  - ハードディスクなどの補助記憶装置のファイルシステム
  - インターネットのドメイン名
  - 階層構造を効率よく管理できますよーってこと
- 2 分木というデータ構造は各要素を次のようにいう
  - 根（ルート）
  - 枝（ブランチ）
  - 節（節点、ノード）
  - 葉（リーフ）
- 完全 2 分木
  - 葉以外の節がすべて 2 つの子を持ち、根から葉までの深さが一様に等しい 2 分木のこと
  - 左から順に葉が埋めていって、その深さの要素が埋め尽くされるまでは次の深さにいかない
  - ヒープや AVL 木は完全 2 分木にあたります
- 2 分探索木
  - 左部分木と右部分木の関係が「左の子 < 親 < 右の子」となる 2 分木
- ヒープ
  - 半順序木木ともいわれ、「親要素が子要素の値以上である」もしくは「子要素が親要素の値以上である」という関係にある 2 分木
- AVL 木
  - どの節においても左部分木と右部分木の高さが 1 以下という関係にある 2 分木
  - 絞り込みに無駄がないので、計算量が少なくて済む
- 2 分木の走査順序
  - 先行順（行きがけ順）
  - 中間順（通りがけ順）
  - 後行順（帰りがけ順）

## 11.9 データを探索するアルゴリズム

- 配列などの多くの箱から特定のデータを探す探索方法に以下の３つがある
  - 線形探索法（平均探索回数は(1 + n)/2）
    - 先頭からループで探していく方法
    - 一つテクニックとして、配列の値に必要なデータが必ずあるという状況を作り出すために、配列の最後にほしい値を挿入しておくというやり方がある？！
  - 2 分探索法（平均探索回数は log2n）
    - 探索対象のデータが昇順や降順といったある規則性に従って、配置されているときに効率よく探索ができる方法
  - ハッシュ法（平均探索回数は 1 回）
    - ハッシュ関数という「一定の計算式」を用いて、データの格納位置を特定する方法。
    - シノニムが発生する可能性があるので、発生した場合は以下の方法がある
      - オープンアドレス法
        - 再ハッシュ関数（基本的にはハッシュ値に+1 をする計算式）を用いて格納位置をずらす方法
      - チェイン法
        - 格納先でポインタを用いて単一方向のリストでデータを数珠つなぎで格納する

## 11.10 データを整列させるアルゴリズム

- 整列の代表的なアルゴリズムには、基本交換法、基本選択法、基本挿入法などがある。
  - 基本交換法（バブルソート）
    - 隣接するデータの大小を比較して、必要に応じて入れ替える（最後までその比較をし終えたら、もう一度先頭から同じことをする）
  - 基本選択法（選択ソート）
    - 対象とするデータの中から最小値（もしくは最大値最大値）のデータを取り出して、先頭のデータと交換。これを繰り返すことで整列させる。（整列対象が少しづつ少なくなってくるイメージ）
  - 基本挿入法（挿入ソート）
    - 対象となるデータを「整列済み」と「未整列のもの」に分ける。未整列のもの一つずつ「整列済み」のデータのどこに挿入するかを考えて全体を整列するのが挿入ソート
  - より高度な整列アルゴリズム
    <!-- TODO: 複雑なので一旦スルー -->
    - シェルソート
    - クイックソート
    - ヒープソート
    - マージソート

## 11.11 オーダ記法

- アルゴリズムの計算量（実行時間）を O 式の形で表すもの。
- 「おおまかな処理の効率」をはかる指標
- アルゴリズムの計算量のおおまかな上限値の傾向を示すためにある
- 探索アルゴリズムのオーダ
  - 線形探索法： O(n)
  - 2 分探索法： O(log2n)
  - ハッシュ法： O(1)
- 整列アルゴリズムのオーダ
  - 基本交換法,基本選択法,基本挿入法： O(n2)
  - シェルソート: O(n1,2)
  - クイックソート、ヒープソート、マージソート： O(nlog2n)

## 11.12 再帰法

- 自身のなかで自分自身を読み出す関数を再帰関数という。
- 自分自身と同じアルゴリズムを繰り返すため
- 再帰アルゴリズム（再帰法をアルゴリズムに取り入れると、簡潔になる）
- 大きな問題を小さな問題に分割して、その一つ一つを解決していくことで結果的に大きな問題を解決する考え方を「分割統治法」という

## 12.1 DMBS と関係データベース

- DBMS（データベース管理システム）とは -　データベースを利用したいアプリケーションに機能を提供するミドルウェア
  - 主に 3 種類の DMBS がある
    - 関係型（表形式）一般的にはこれ
    - 階層型（ツリー上）
    - ネットワーク型（網状）
  - 正規化が必要（データベースを最適化する）情報を切り出す
  - 関係演算には選択、射影、結合がある。
    - 選択：行を取り出す
    - 射影：列を取り出す
    - 結合：一部をつなぎあわせる
  - これらをすることでビュー表ができる
  - データベースの設計
    - 概念設計：現実の世界からデータを抽出してモデル化（概念モデル）
    - 論理設計：データベースで表現する形にモデル化（論理モデル）
    - 物理設計：ハードウェアなど物理的な構造をモデル化（物理モデル）
  - スキーマ（データベースの構造や仕様を定めるもので、3 層スキーマ構造にしてデータの独立性を高める！）
    - 外部スキーマ ： 必要となるデータの見方を設計（ビューなど）
    - 概念スキーマ ： データの論理的関係を表現（表の定義はここ、DB そのもの）
    - 内部スキーマ ： データの物理的関係を表現（ハードウェアにそう記憶させるかはここ）

## 12.2 主キーと外部キー

-　行を特定するために主キーが使われる？

- 表と表に関係性持たせるために使われることもある
- 主キーとなりうるキーが複数ある場合がある
  - 候補キー
  - 主キーではなく候補キーを代替キーという
- データベースのデータに整合性を取るため整合性制約というものがある
  - 主キーの場合
    - 一意性制約：値の重複がない
    - notnull 制約 ：値が空じゃない
  - 外部キーの場合
    - 参照制約：外部キーに含まれる値は、参照先となる表の列内に必ず存在しなければならない
  - インデックス
    - データベースの検索速度を上げるために、特定のデータに index をつけることもできる

## 12.3 正規化

- データに矛盾や重複が生じないように最適化を行うこと
- 正規化の目的は、データに矛盾や重複を生じさせないこと。
- 関係データベースでは、第 3 整形の表を管理する！
- 主キーが決まれば、一意の値が決まる列の関係を関数従属という
- 複合キーの一部が決まれば、一意の値が決まる関係を部分関数従属という
- 非正規化
  - 正規化されていない繰り返し部分持つ表
- 第 1 正規化
  - 繰り返し部分をなくした表
- 第 2 正規化
  - 部分関数従属している部分を切り出したかたち
- 第 3 正規化
  - 主キー以外の列に関数従属している部分を切り出した形
